from pydantic import BaseModel, Field, field_validator, constr
from typing import Literal, Optional

# Custom string type ensuring non-blank input after stripping whitespace.
NonBlankStr = constr(strip_whitespace=True, min_length=1)

class ChatMessageRequest(BaseModel):
    login_session_id: NonBlankStr = Field(..., description="Login session ID for which the chat session needs to be initialized.")
    chat_session_id: NonBlankStr = Field(..., description="Unique identifier for the chat session.")
    question: NonBlankStr = Field(..., description="The question being asked to the LLM in English.")
    question_kannada: str | None = Field(None, description="The question being asked to the LLM in Kannada.") # Can be none
    input_type: Literal["manual-english", "manual-kannada", "button", "default", "system"] = Field(..., description="The type of input being provided to the LLM.")
    student_name: NonBlankStr = Field(..., description="The student involved in this conversation")
    user_full_name: NonBlankStr = Field(..., description="The user asking the question")
    user_email: Optional[str] = Field(None, description="Email of the user (added for DynamoDB)")

    @field_validator("input_type")
    # Validator to ensure input_type is one of the allowed values.
    def validate_input_type(cls, v):
        if v not in ["manual-english", "manual-kannada", "button", "default", "system"]:
            raise ValueError("Invalid input type")
        return v

class ChatMessageResponse(BaseModel):
    success: bool = Field(..., description="Whether the function call was successful.")
    message: str | None = Field(None, description="Message if the chat message was retrieved successfully.")
    result: bool | None = Field(None, description="Whether the chat message was retrieved successfully.")
    data: str | None = Field(None, description="The response generated by the model.")
    timestamp: str | None = Field(None, description="Timestamp of the chat message retrieval.")